слабая часть кода  в уязвимости Gcd и цикле while(a*b)
это условие проверяет что оба числа не равны 0
при переполнении результат может стать нулевым даже если a b не равны 0

из за 32-битной системы операции выполняются по модулю 2^32 
т.е. если a*b кратно 2^32 то результат = 0

можно использовать a=2^k тогда b= 2^(32-k)
a*b=2^32 сравнимо с 0 (mod 2^32)

примеры:

a = 4, b = 1073741824

a = 16, b = 268435456

и т.п.

так же можно рассмотреть пример менее очевидного результата

a = 268435456, b = 268435472

в целом:

когда условие a*b становится ложным из за переполнения цикл завершается и функция возвращает макс из текущих значений a b но это значение может быть не на самом деле наибольшим общим дел чисел что в последствии приводит к расхождению с std::gcd


ТЕОР 1.3.2

1) путем минимального подбора найдем пару 4 и 1073741824 тк при значениях 1 2 3 не возникает переполнения которая могла бы нарушить работу алгоритма
А для 4 существует такое вышеуказанное число при котором результат кратен 2^32 что приводит к нулевому результату при переполнении


2) множество всех пар чисел (a,b) можно расписат:

W = {(a, b) | ∃k: (a_k × b_k) mod 2³² = 0}

где a_k b_k промежуточные значения цикла while функции Gcd

условие означает что на некотором шаге вычислений произведение промежуточных значений становится кратным 2^32

альтернативное описание с учетом неопределенного поведения:

W' = {(a, b) | ∃k: a_k × b_k > INT_MAX}

что включает в себя все пары при обработке которых возникает целочисленное переполнение на каком либо этапе работы алгоритма


3) Пусть a и b не принадлежат W' и W
Однако возникает ошибка по алгоритму Евклида

